* [2025-03-08 Sat]
Oops, didn't update the devlog in forever. To be fair, not much has been happening either.

Slowly been chipping away at some boss infra stuff. Most of it is in place now, except
for rendering the spell name and the health bar.

Still unclear how I'm going to represent health in the context of having multiple
nons/spells, but it'll be an important thing to figure out before I continue on.

Once I finish those three things and lasers, it'll /finally/ be time to actually start
designing the stage danmaku.

* [2024-11-23 Sat]
Started this devlog to help track progress and motivate myself. A bit late since a lot of
the core infra of the game has already been laid down, but late is better than never.

Added support in the coroutine system for generic pre- and post-hooks that are run before
and after each time a coroutine resumes. This will be used for running general bookkeeping
needed for all enemy types. Slightly worried if I can keep a good separation between
the bookkeeping and the main task logic, but won't dwell on it until it becomes a problem.

Sorted bullets before render. Just uses the allocating vector-sort instead of a dedicated
buffer, since GC's generally don't like old-to-young gen pointers, and there's no optimized
primitive to blit one vector to another. It seems to perform just fine.

Also went on a sidequest to finally read up about how errors and conditions work in
R6RS/Chez. I was thinking it'd be nice to have exception handlers around certain parts of
the code like each coroutine resume for better interactive dev (if it's possible to
recover from such errors, I'm not sure how flexible Chez is here).

Turns out the condition system is kinda complex because it has additional polymorphism
behavior beyond which R6RS records specify. Chez provides the continuation for lots of
condition types, but you can't use it to implement CL style restarts, presumably because
the point at which the continuation is captured is always "too late"?

For example, this:
#+BEGIN_SRC scheme
(define (p m) (display m) (newline))

(guard (x [else
		   (p "before")
		   ((condition-continuation x) 1) ;; try to resume from the (error) call
		   (p "after")])
  (let ([f (error 'who "what")])
	(p "out")
	f))

(p "done")
#+END_SRC
does not print "after" nor "out".

So any error handling I do won't provide a friendlier repl experience, though I could
presumably fail-safe and discard the erroring enemy to prevent a program crash.

Next: Want to actually start implementing the movement animation system that I've been
procastinating about the last 3 weeks. At least the infra-side tracking of the delta
motion if not the actual rendering.

