* [2026-02-04 Wed]
Hacked up Aiko non2. It's simple but serves the purpose of telling the player more bouncy
bullets are coming up ahead. As always, there's some balancing adjustments needed but the
core is sound.

When characters switch out, I programmed it so that the exiting character uses a subtask
and the incoming character does it in their spawn coroutine. I'm not sure why I had it
that way, but trying to move the exiting character' exit from a subtask to the main task
crashes. Didn't look into it further but logging here in case something comes up again.

Also, when programming boss attacks, I find it most useful to put everything into a
subtask gated by the keep-running function. If you do things in the context of the main
task then every kind of looping you have needs to check keep-running to make sure you're
not hanging around past when the enemy's health or time limit is depleted. It's just
easier to put everything into a subtask and have that check keep-running for you.

This might be a mismatch with the whole "attacks tail-call each other" paradigm, but I
think that design is still useful because it allows you to jump to specific phases and
msot importantly keep playing after that phase is done.

* [2026-01-31 Sat]
(late night)

Aiko sp1 is done but pretty unbalanced. I was fooling around with Hazuki sp2, which
originally was intending to be a CIV reference what with ghost/wisps attacking Hazuki and
getting a bonus for saving her, but after some thought I felt like it would kinda be
reflecting on her character in a negative light, so I've tabled the idea.

Instead, moving on to aiko sp2 which is the next best baked idea I have. Got the lasers
for the field setup, next is to set up the bouncing ball physics. Not sure yet whether i
want the shots to interact with the ball, because the fire rate here is too fast. Either
shots don't interact or we'd have to slow the fire rate down to hrtp speeds, or disable
autofire. idk.

Originally I had an idea as well to do some sort of "footrace" thing to tie in with Aiko's
running career in the light novels, but given this spell is right before the survival I
don't think a prolonged attack is appropriate, so the penalty shootout idea is what we're
going with. Need to research pong AI's and how they angle their shots, but honestly it's
not hard to rederive myself.

* [2026-01-12 Mon]
Just some quick noodling around with aiko sp1. I like where it's going; obviously it's
unbalanced and visually barebones, but I think the basic skeleton is quite serviceable.

* [2026-01-10 Sat]
(late night)

Loading up some spell backgrounds from a pattern book I bought a while back.

Spent a long time futzing about with Raylib's DrawTexturePro again, whose origin/rotation
arguments still confuse me to this day. I'm just going to ignore it and do things using the
GL matrix.

The pattern book has some circular patterns with a "background" color in the middle that's
obviously meant to become transparent when you use the pattern, but I tried some of them
out and they don't look too good when the stage background shows underneath. So I settled
on the ones that are mostly opaque.

At first I rendered the texture shrunk too small and was wondering why it looked
wrong. After enlarging, /then/ I got that nice maingame feel. Though you still want to
shrink a bit so that you get as much of the detail from the original texture as possible,
but not too much that the square corners of the texture start showing up as the texture
spins. I think what we landed on in the end looks alright.

* [2026-01-08 Thu]

- Added a filled circle hint particle
- Made spawn-particle call make-particle for you
- Some rough sketching of aiko sp1. Found a pretty major bug in the coro library, which is
  that sub-subtasks don't exit when their parent exits normally
  (i.e. without the parent's keep-running becoming false).
  Fixed that. Doesn't seem like anything in the stage is relying on it.

* [2025-12-31 Wed]
Going to try harder this upcoming year to write in the devlog every day I do any
development. Just some cleaning up today, adding in fireball bullets, and granularizing
the roadmap more.

* [2025-11-15 Sat]
How should the dialogue system work?

probably plain readable data in external file
something like:

((type . reimu) (text . "First line
second line"))
((type . doremi-surprised) (text . "Reply"))
"Plain string means same character and expression as previous"
((type . doremi-enter)) ;; dummy types interpreted specially by the code
((type . bossmusic))

see dialogue/main.dat for a sketch.


* [2025-11-06 Thu]
Basic replays exist but they're pretty buggy and there's no UI.
Main problems:

1. In the transition from gui to game, things can get wonky because technically a
   frame can be skipped or happen twice. This can be reproed by just trying to
   pause a replay during playback, it'll crash right when you unpause. Also
   pausing during a real run will cause the replay output stream to skip a frame.
2. More concerning bug is if a replay is restarted from the pause menu, it
   mysteriously desyncs, but only 1k-2k frames after. The beginning of the replay
   still works properly. This is the scariest case since it passes some of the
   sanity checks but not all, which means I'm leaking some sort of state across
   playback instances...but not sure what.
3. Not having UI for saving the replays and such makes testing annoying as I can
   only have one test replay at once and it gets blown away when I do a full run.
4. Still don't have a way to mark replays that "end early" via pause->save and quit.
   These just crash after the playback runs out of data to read.
   
I'll probably actually ignore the bugs for now and implement the UI parts first
just to make debugging less of a pain.

* [2025-11-04 Tue]
Some brief brainstorming/planning for replays. I tend to just go for it when
coding on this project but i think it's worth planning just a bit for this
so I don't have to do too much backtracking.

Replays will be plaintext (potentially with extra compression later but it will
be optional/layered on top s.t. plaintext ones are still loadable).
This makes it easy to debug when things go wrong.

It'll be line-based. Last line will be a score-entry record to carry the
score/timestamp/signature/clear state of the replay. Easy to reuse the existing
struct here. Last line to avoid having to copy everything after the replay ends.
When loading replays we'll read the entire thing into memory anyways, so

Each subsequent line will be a vector of the following fields

- frame number
- edge-pressed vkeys
- edge-released vkeys
- level-pressed vkeys
- (no edge pressed raw since no gameplay should ever read that)
- (optional) whether an unpause happened this frame and if so how long paused in realtime
- (optional) game-rng checkpoint state. should be verified at the beginning of the frame.
  - REQUIRED for frame 0
- (optional) END flag marking the end of the replay, for replays that quit out
  in the middle of the stage
  
The file should naturally be sorted by frame. We'll sort on load so that we can
naturally progress to the next entry without having to build a hashmap of
frame number -> entry.

We should write a line to the file each frame so we can at least attempt to have
failure recovery (?) though probably won't provide that as a feature.
But savvy people can edit the replay to salveage partial replays.

If there are no pressed or released keys and none of the optional fields are set,
then we can omit the record completely for that frame to save space.

* [2025-09-26 Fri]
Back from vacation. The entire stage portion is completely done. Assessing where we are
now, I think I want to work on the dialogue system next, then replays. So it'll be a bit
of infrastructure time instead of pattern work, but I'm keeping some brainstorming going
on in the background for when the time comes.

I probably won't have strict music syncing with the boss fight because it's really hard to
do if the music isn't designed with the fight in mind. The BGM will probably just be a
looped version of Half Point.

I also need to start practicing art again because I want to draw all the character
portraits myself. If I'm extra ambitious, maybe I'll even have different portraits for the
spell card cutins. This can proceed in parallel with working on the infra bits.

* [2025-08-23 Sat]
Pretty much all but one chapter of the stage patterns are in place.

Some replay brainstorming:

We'll have to first refactor input to introduce a layer of indirection: we need to capture
the current state of any level-triggered keys, as well as the list of all edge-triggered
key changes that happened in the frame. This needs to happen at the start of the frame and
produce a snapshot of the input state, and the handle-input function should operate solely
based on this snapshot.
This snapshot will also be used to write the input state for that frame of the replay.

(This might require another prerequisite refactor step to abstract away from the raw keys
and deal with what danmakufu calls the virtual keys (up down left right shoot bomb, etc.))

Then, playing replays is just setting the rng seed properly, then providing the snapshots
to handle-input from the replay file instead of the live input devices.

We can also save the rng state into the replay every X frames and compare it to the live
game-rng state to ensure we don't have any rng-based desyncs. Probably disabled in prod or
set to a pretty high interval (every 10 seconds?).

* [2025-05-11 Sun]
Some chapter 1 hacking, but I also took some time to figure out the Windows build process.
It's actually super simple, everything basically just works. The build.ss script runs
directly under WINE and with raylib.dll in the working directory the game starts and runs
just as expected.

Distribution for Windows will just be zipping up the Chez Scheme install folder alongside
thdawn.boot and raylib.dll, and maybe a bat script to start the game.

The statically-linked/dependency-bundled distribution for Linux will be similar, if I choose
to make one.

* [2025-05-10 Sat]
Now mostly at a point where I should just be banging out the stage patterns, though I've
instead been faffing about, mostly with splines and how I can more cleanly represent enemy
movement that isn't purely aligned with the cardinal/ordinal axes.

* [2025-03-08 Sat]
Oops, didn't update the devlog in forever. To be fair, not much has been happening either.

Slowly been chipping away at some boss infra stuff. Most of it is in place now, except
for rendering the spell name and the health bar.

Still unclear how I'm going to represent health in the context of having multiple
nons/spells, but it'll be an important thing to figure out before I continue on.

Once I finish those three things and lasers, it'll /finally/ be time to actually start
designing the stage danmaku.

* [2024-11-23 Sat]
Started this devlog to help track progress and motivate myself. A bit late since a lot of
the core infra of the game has already been laid down, but late is better than never.

Added support in the coroutine system for generic pre- and post-hooks that are run before
and after each time a coroutine resumes. This will be used for running general bookkeeping
needed for all enemy types. Slightly worried if I can keep a good separation between
the bookkeeping and the main task logic, but won't dwell on it until it becomes a problem.

Sorted bullets before render. Just uses the allocating vector-sort instead of a dedicated
buffer, since GC's generally don't like old-to-young gen pointers, and there's no optimized
primitive to blit one vector to another. It seems to perform just fine.

Also went on a sidequest to finally read up about how errors and conditions work in
R6RS/Chez. I was thinking it'd be nice to have exception handlers around certain parts of
the code like each coroutine resume for better interactive dev (if it's possible to
recover from such errors, I'm not sure how flexible Chez is here).

Turns out the condition system is kinda complex because it has additional polymorphism
behavior beyond which R6RS records specify. Chez provides the continuation for lots of
condition types, but you can't use it to implement CL style restarts, presumably because
the point at which the continuation is captured is always "too late"?

For example, this:
#+BEGIN_SRC scheme
(define (p m) (display m) (newline))

(guard (x [else
		   (p "before")
		   ((condition-continuation x) 1) ;; try to resume from the (error) call
		   (p "after")])
  (let ([f (error 'who "what")])
	(p "out")
	f))

(p "done")
#+END_SRC
does not print "after" nor "out".

So any error handling I do won't provide a friendlier repl experience, though I could
presumably fail-safe and discard the erroring enemy to prevent a program crash.

Next: Want to actually start implementing the movement animation system that I've been
procastinating about the last 3 weeks. At least the infra-side tracking of the delta
motion if not the actual rendering.

