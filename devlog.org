* [2025-08-23 Sat]
Pretty much all but one chapter of the stage patterns are in place.

Some replay brainstorming:

We'll have to first refactor input to introduce a layer of indirection: we need to capture
the current state of any level-triggered keys, as well as the list of all edge-triggered
key changes that happened in the frame. This needs to happen at the start of the frame and
produce a snapshot of the input state, and the handle-input function should operate solely
based on this snapshot.
This snapshot will also be used to write the input state for that frame of the replay.

(This might require another prerequisite refactor step to abstract away from the raw keys
and deal with what danmakufu calls the virtual keys (up down left right shoot bomb, etc.))

Then, playing replays is just setting the rng seed properly, then providing the snapshots
to handle-input from the replay file instead of the live input devices.

We can also save the rng state into the replay every X frames and compare it to the live
game-rng state to ensure we don't have any rng-based desyncs. Probably disabled in prod or
set to a pretty high interval (every 10 seconds?).

* [2025-05-11 Sun]
Some chapter 1 hacking, but I also took some time to figure out the Windows build process.
It's actually super simple, everything basically just works. The build.ss script runs
directly under WINE and with raylib.dll in the working directory the game starts and runs
just as expected.

Distribution for Windows will just be zipping up the Chez Scheme install folder alongside
thdawn.boot and raylib.dll, and maybe a bat script to start the game.

The statically-linked/dependency-bundled distribution for Linux will be similar, if I choose
to make one.

* [2025-05-10 Sat]
Now mostly at a point where I should just be banging out the stage patterns, though I've
instead been faffing about, mostly with splines and how I can more cleanly represent enemy
movement that isn't purely aligned with the cardinal/ordinal axes.

* [2025-03-08 Sat]
Oops, didn't update the devlog in forever. To be fair, not much has been happening either.

Slowly been chipping away at some boss infra stuff. Most of it is in place now, except
for rendering the spell name and the health bar.

Still unclear how I'm going to represent health in the context of having multiple
nons/spells, but it'll be an important thing to figure out before I continue on.

Once I finish those three things and lasers, it'll /finally/ be time to actually start
designing the stage danmaku.

* [2024-11-23 Sat]
Started this devlog to help track progress and motivate myself. A bit late since a lot of
the core infra of the game has already been laid down, but late is better than never.

Added support in the coroutine system for generic pre- and post-hooks that are run before
and after each time a coroutine resumes. This will be used for running general bookkeeping
needed for all enemy types. Slightly worried if I can keep a good separation between
the bookkeeping and the main task logic, but won't dwell on it until it becomes a problem.

Sorted bullets before render. Just uses the allocating vector-sort instead of a dedicated
buffer, since GC's generally don't like old-to-young gen pointers, and there's no optimized
primitive to blit one vector to another. It seems to perform just fine.

Also went on a sidequest to finally read up about how errors and conditions work in
R6RS/Chez. I was thinking it'd be nice to have exception handlers around certain parts of
the code like each coroutine resume for better interactive dev (if it's possible to
recover from such errors, I'm not sure how flexible Chez is here).

Turns out the condition system is kinda complex because it has additional polymorphism
behavior beyond which R6RS records specify. Chez provides the continuation for lots of
condition types, but you can't use it to implement CL style restarts, presumably because
the point at which the continuation is captured is always "too late"?

For example, this:
#+BEGIN_SRC scheme
(define (p m) (display m) (newline))

(guard (x [else
		   (p "before")
		   ((condition-continuation x) 1) ;; try to resume from the (error) call
		   (p "after")])
  (let ([f (error 'who "what")])
	(p "out")
	f))

(p "done")
#+END_SRC
does not print "after" nor "out".

So any error handling I do won't provide a friendlier repl experience, though I could
presumably fail-safe and discard the erroring enemy to prevent a program crash.

Next: Want to actually start implementing the movement animation system that I've been
procastinating about the last 3 weeks. At least the infra-side tracking of the delta
motion if not the actual rendering.

